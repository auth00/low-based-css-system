@use 'sass:map';

@import './tools.scss';

/*
 * Mixin used to create custom property with content class fallback
 */
@mixin prop($prop, $realm, $value, $name: '', $class: '') {
  $custom-props: $custom-props !global;
  @if not map.has-key($custom-props, $realm) {
    $custom-props: map.set($custom-props, $realm, ()) !global;
  }
  @if $class != '' {
    $custom_prop: '--#{$realm}--#{$class}--#{$name}--#{$prop}';
    $custom_prop_fallback: '--#{$realm}--#{$class}--#{$prop}';

    --_#{$prop}: var(#{$custom_prop}, var(#{$custom_prop_fallback}, #{$value}));

    $custom-props: map.set(
      $custom-props,
      $realm,
      map.merge(
        map.get($custom-props, $realm),
        (
          $custom_prop_fallback: 'revert',
        )
      )
    ) !global;
    $custom-props: map.set(
      $custom-props,
      $realm,
      map.merge(
        map.get($custom-props, $realm),
        (
          $custom_prop: $value,
        )
      )
    ) !global;
  } @else {
    $custom_prop: '--#{$realm}--#{$prop}';

    --_#{$prop}: var(#{$custom_prop}, #{$value});

    $custom-props: map.set(
      $custom-props,
      $realm,
      map.merge(
        map.get($custom-props, $realm),
        (
          $custom_prop: $value,
        )
      )
    ) !global;
  }
}

/*
 * Mixin used to create typografy sets
 */
@mixin typesetting($name, $selectors, $value) {
  #{$selectors} {
    @include content--class--text($name);

    @each $realm,
      $props
        in (
          space: (
            vspace-before,
            vspace-after,
          ),
          typesetting: (
            font-size,
            font-family,
            font-weight,
            line-height,
          ),
          color-scheme: (
            text-color,
          )
        )
    {
      @each $prop in $props {
        @if map.has-key($value, $prop) {
          @include prop($prop, $realm, map.get($value, $prop), $name, 'text');
        } @else {
          @include prop($prop, $realm, inital, $name, 'text');
        }
      }
    }
  }
}

/*
 * Resets all custom properties in a given realm
 */
@mixin realm-reset($realm) {
  @each $custom_prop,
    $custom_prop_value in map-sort(map.get($custom-props, $realm))
  {
    #{$custom_prop}: #{$custom_prop_value};
  }
}

/*
* Debug purposes only
* Theme is a special abstract class that defines every custom property
* used in the css system.
*/
@mixin theme-props {
  @each $realm, $realm-props in $custom-props {
    @each $custom_prop, $custom_prop_value in map-sort($realm-props) {
      --_#{$custom_prop}: #{$custom_prop_value};
    }
  }
}

/*
 * The content items share some properties but they
 * do not share a "base class". The class .content 
 * can be used to make any markup "content" but it 
 * is also extended by other tags and classes like 
 * p, img and .preamble to make them become content.
 */
%content {
  --_content--air: var(--content--air, var(--content--air--default));

  --_text-align: var(
    --content--text-align,
    var(--content--text-align--default)
  );
}

%content {
  position: relative;
  margin-top: var(--_vspace-before);
  margin-bottom: var(--_vspace-after);
  margin-inline: auto;
  padding: 0 var(--_content--air);
  transition: color 1s;
}

.content {
  @extend %content;
}

.content--align--center {
  --content--text-align: center;
}

/*
 * These utility modifiers can be used to alter 
 * content behaviour.
 */
.content--width--normal {
  // "normal" is a reserved content width keyword
  //--content--width: var(--content--width--normal, 500px);
  --width--max-width: var(--width--max-width--normal, 500px);
}

.content--width--full {
  // "full" is a reserved content width keyword and is always 100%
  --width--max-width: 100%;
  ///*@include realm-reset(width);*/
}

/*
 * Air usage can be set per content instance using a class.
 */
.content--air--none {
  --content--air: 0;
}

.content--air--normal {
  --content--air: var(--content--air--normal, 5px);
}

/*
 * The total margin is largest positive margin -
 * largest negative margin so this will make sure
 * that the margin above and below an item is always
 * 0.
 *
 * Due to how margin collapsing works this markup somewhere 
 * between two content elements will make them have no
 * space between them.
 * <div class="content--vspace--none"><div></div></div>
 *
 * Any content class can also implement a "marginkiller"
 * by adding @extend .content--vspace--none to to some 
 * part of the component markup. Columns does this for each
 * item to ensure css "gap" is the feature providing the space.
 */
.content--vspace--none {
  @extend .content--vspace-before--none;
  @extend .content--vspace-after--none;
}

.content--vspace-before--none {
  margin-top: 999px;

  > * {
    margin-top: -999px;
  }
}

.content--vspace-after--none {
  margin-bottom: 999px;

  > * {
    margin-bottom: -999px;
  }
}

/*
 * Default anonymous classes to support different
 * default behaviors for different kind of content.
 */
%content--defaults--width--normal {
  --width--max-width--default: var(--width--max-width--normal, 600px);
}

%content--defaults--width--full {
  --width--max-width--default: 100%;
}

%content--defaults--air--none {
  --content--air--default: 0px;
}

%content--defaults--air--normal {
  --content--air--default: var(--content--air--normal, 5px);
}

/*
 * Media is a content class
 * defaults:
 *  * air:off
 *  * width:normal
 */
%content--class--media {
  @extend %content;
  @extend %content--defaults--air--none;
  @extend %content--defaults--width--normal;
}

/*
 * All widgets need to be at least two divs
 * div > div
 * defaults:
 *  * air:off
 *  * width:full
 */
%content--class--widget {
  @extend %content;
  @extend %content--defaults--air--none;
  @extend %content--defaults--width--full;

  > div {
    display: block flow-root;
  }
}

@mixin content--class--width($class: '', $realm: '') {
  @if $realm == '' {
    @include prop(max-width, width, var(--width--max-width--default, 100%));
  } @else {
    @include prop(
      max-width,
      width,
      var(--width--max-width--default, 100%),
      $class,
      $realm
    );
  }

  max-width: var(--_max-width);
}

@mixin content--class--width-with-viewport-air($class: '', $realm: '') {
  @include content--class--width($class, $realm);

  /*
   * Added 
   */
  max-width: \min(
    var(--_max-width),
    calc(
      100vw - var(--scrollbar--width, 0px) - var(--content--air--default, 0px) *
        2
    )
  );
}

/*
 * content of class color-scheme is are
 * capable of altering the current color-scheme
 * All color-scheme classes are also widgets
 */
%content--class--color-scheme {
  @extend %content--class--widget;

  @include prop('background', color-scheme, revert);
  @include prop('background-contrast', color-scheme, rgb(0, 0, 0, 0.2));

  @include realm-reset(color-scheme);

  display: flow-root; // Needed to make sure margins are filled
  background: var(--_background);

  transition: background-color 1s;

  > div {
    --color-scheme--background: var(
      --color-scheme--background-contrast,
      revert
    );
  }
}

/*
 * Text is a content class
 * defaults:
 *  * air:on
 *  * width:normal
 */
@mixin content--class--text($name: '') {
  @extend %content;

  @if $name == '' {
    @include content--class--width-with-viewport-air('default', 'text');
  } @else {
    @include content--class--width-with-viewport-air($name, 'text');
  }

  @extend %content--defaults--air--normal;
  @extend %content--defaults--width--normal;

  font-family: var(--_font-family);
  font-size: var(--_font-size);
  line-height: var(--_line-height);
  text-align: var(--_text-align);
  color: var(--_text-color);
}

/*
 * Groups provides a way to group content together and
 * should handle stuff like:
 *  * color-schemes
 *  * dividers like borders
 *  * ???
 *
 * The group resets the flow box
 * The markup is always 2 divs with modifiers on the first:
 *  div.group[.modifiers] > div
 *
 *
 */
.group {
  @extend %content--class--color-scheme;

  @include prop(vspace--header, space, 0px, default, group);
  @include prop(vspace--footer, space, 0px, default, group);

  > div {
    overflow-x: auto;
    margin-top: var(--_vspace--header);
    margin-bottom: var(--_vspace--footer);

    > :first-child {
      .group--header {
        margin-top: calc(-1 * var(--_vspace--header));
      }
    }

    > :last-child {
      .group--footer {
        margin-bottom: calc(-1 * var(--_vspace--footer));
      }
    }

    > :first-child:last-child {
      .group--banner {
        margin-top: calc(-1 * var(--_vspace--header));
        margin-bottom: calc(-1 * var(--_vspace--footer));
      }
    }
  }
}

/*
 * TODO: Define a
 */
.columns {
  @extend %content--class--widget;
  @extend %content--defaults--air--normal;

  //grid-template-columns: repeat(3, 1fr);
  //

  > div {
    display: flex;
    flex-wrap: wrap;
    align-content: center;
    gap: 20px;
    > div {
      flex: 1 1 20px;
      > div {
        @extend .content--vspace--none;
      }
    }
  }
}

/*
 * TODO: This needs to be worked more on
 */
/*
 * This is some sort of generic image.
 * This should probably support <picture>
 * and other image related features.
 */
.img {
  @extend %content--class--media;
  @extend %content--defaults--air--none;

  @include content--class--width(img, media);

  @include prop(vspace-before, space, 0px, img, media);
  @include prop(vspace-after, space, 0px, img, media);

  > div {
    background-size: cover;
    height: 90px;
    max-width: 100%;
    background-image: url(https://picsum.photos/400/30);
  }
}
.img-embed {
  @extend %content--class--media;
  @extend %content--defaults--air--normal;

  @include content--class--width-with-viewport-air(img-embed, media);

  @include prop(vspace-before, space, 0px, img-embed, media);
  @include prop(vspace-after, space, 0px, img-embed, media);

  > div {
    background-size: cover;
    height: 90px;
    max-width: 100%;
    background-image: url(https://picsum.photos/400/30);
  }
}
